<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal Spreadsheet Grid</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1e1e1e;
            color: #ffffff;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 14px;
            overflow: hidden;
        }

        .spreadsheet-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .spreadsheet-grid {
            flex: 1;
            display: table;
            width: 100%;
            border-collapse: collapse;
        }

        .row {
            display: table-row;
            border-bottom: 1px solid #404040;
        }

        .cell {
            display: table-cell;
            border-right: 1px solid #404040;
            padding: 8px 12px;
            vertical-align: top;
            outline: none;
            min-height: 40px;
            line-height: 24px;
        }

        .cell:focus {
            background: #2d2d2d;
            border: 2px solid #4fc3f7;
            margin: -1px;
        }

        .command-cell {
            width: 120px;
            font-weight: bold;
            color: #4fc3f7;
            background: #242424;
        }

        .parameter-cell {
            background: #1e1e1e;
            color: #cccccc;
            width: auto;
            padding: 4px;
        }

        .nested-grid {
            background: #282828;
            border-radius: 4px;
            border: 1px solid #404040;
            overflow: hidden;
        }

        .nested-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        .nested-header {
            background: #323232;
            color: #cccccc;
            font-weight: bold;
            text-align: center;
            padding: 4px 8px;
            border-bottom: 1px solid #404040;
        }

        .nested-cell {
            padding: 4px 8px;
            border-right: 1px solid #404040;
            border-bottom: 1px solid #404040;
            outline: none;
            min-height: 24px;
            line-height: 16px;
        }

        .nested-cell:focus {
            background: #3d3d3d;
            border: 2px solid #4fc3f7;
            margin: -1px;
        }

        .nested-param-key {
            color: #ffb74d;
            background: #2a2a2a;
            width: 50%;
        }

        .nested-param-value {
            color: #81c784;
            background: #282828;
            width: 50%;
        }

        .nested-cell[contenteditable="true"]:empty::before {
            content: attr(data-placeholder);
            color: #666666;
            font-style: italic;
        }

        .cell[contenteditable="true"]:empty::before {
            content: attr(data-placeholder);
            color: #666666;
            font-style: italic;
        }

        .row:nth-child(even) .command-cell {
            background: #282828;
        }

        .row:nth-child(even) .parameter-cell {
            background: #222222;
        }
    </style>
</head>
<body>
    <div class="spreadsheet-container">
        <div class="spreadsheet-grid" id="grid">
            <!-- Rows will be generated by JavaScript -->
        </div>
    </div>

    <script>
        class MinimalSpreadsheet {
            constructor(container) {
                this.container = container;
                this.rows = [];
                this.currentFocus = { row: 0, col: 0 };
                this.init();
            }

            init() {
                // Start with 20 empty rows
                for (let i = 0; i < 20; i++) {
                    this.addRow();
                }
                this.render();
                this.setupEventListeners();
                
                // Focus first cell
                setTimeout(() => {
                    this.focusCell(0, 0);
                }, 100);
            }

            addRow() {
                this.rows.push({
                    command: '',
                    parameters: [
                        { key: '', value: '' },
                        { key: '', value: '' }
                    ]
                });
            }

            render() {
                const html = this.rows.map((row, rowIndex) => {
                    return `
                        <div class="row" data-row="${rowIndex}">
                            <div class="cell command-cell" 
                                 contenteditable="true" 
                                 data-row="${rowIndex}" 
                                 data-col="0"
                                 data-placeholder="Type command...">${row.command}</div>
                            <div class="cell parameter-cell">
                                ${this.renderNestedGrid(row, rowIndex)}
                            </div>
                        </div>
                    `;
                }).join('');
                
                this.container.innerHTML = html;
            }

            renderNestedGrid(row, rowIndex) {
                return `
                    <div class="nested-grid">
                        <table class="nested-table">
                            <thead>
                                <tr>
                                    <th class="nested-header">Parameter</th>
                                    <th class="nested-header">Value</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${row.parameters.map((param, paramIndex) => `
                                    <tr>
                                        <td class="nested-cell nested-param-key" 
                                            contenteditable="true"
                                            data-row="${rowIndex}" 
                                            data-col="1" 
                                            data-param="${paramIndex}"
                                            data-param-col="0"
                                            data-placeholder="param...">${param.key}</td>
                                        <td class="nested-cell nested-param-value" 
                                            contenteditable="true"
                                            data-row="${rowIndex}" 
                                            data-col="1" 
                                            data-param="${paramIndex}"
                                            data-param-col="1"
                                            data-placeholder="value...">${param.value}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            }

            setupEventListeners() {
                this.container.addEventListener('input', (e) => {
                    const cell = e.target;
                    if (!cell.classList.contains('cell') && !cell.classList.contains('nested-cell')) return;

                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    if (col === 0) {
                        // Command cell
                        this.rows[row].command = cell.textContent;
                    } else if (cell.classList.contains('nested-cell')) {
                        // Nested parameter cell
                        const paramIndex = parseInt(cell.dataset.param);
                        const paramCol = parseInt(cell.dataset.paramCol);
                        
                        if (paramCol === 0) {
                            this.rows[row].parameters[paramIndex].key = cell.textContent;
                        } else {
                            this.rows[row].parameters[paramIndex].value = cell.textContent;
                        }
                    }

                    // Auto-expand: add new row if typing in last row
                    if (row === this.rows.length - 1 && cell.textContent.trim()) {
                        this.addRow();
                        this.render();
                        this.restoreFocus();
                    }
                });

                this.container.addEventListener('keydown', (e) => {
                    this.handleKeydown(e);
                });

                this.container.addEventListener('focus', (e) => {
                    if (e.target.classList.contains('cell') || e.target.classList.contains('nested-cell')) {
                        const row = parseInt(e.target.dataset.row);
                        const col = parseInt(e.target.dataset.col);
                        
                        if (e.target.classList.contains('nested-cell')) {
                            const paramIndex = parseInt(e.target.dataset.param);
                            const paramCol = parseInt(e.target.dataset.paramCol);
                            this.currentFocus = { row, col, param: paramIndex, paramCol };
                        } else {
                            this.currentFocus = { row, col };
                        }
                    }
                }, true);
            }

            handleKeydown(e) {
                const focus = this.currentFocus;
                const { row, col } = focus;

                switch (e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        if (focus.param !== undefined) {
                            // In nested grid
                            if (focus.param > 0) {
                                this.focusNestedCell(row, focus.param - 1, focus.paramCol);
                            } else {
                                this.focusCell(Math.max(0, row - 1), 0);
                            }
                        } else {
                            this.focusCell(Math.max(0, row - 1), col);
                        }
                        break;
                    
                    case 'ArrowDown':
                        e.preventDefault();
                        if (focus.param !== undefined) {
                            // In nested grid
                            if (focus.param < 1) {
                                this.focusNestedCell(row, focus.param + 1, focus.paramCol);
                            } else {
                                this.focusCell(Math.min(this.rows.length - 1, row + 1), 0);
                            }
                        } else {
                            this.focusCell(Math.min(this.rows.length - 1, row + 1), col);
                        }
                        break;
                    
                    case 'ArrowLeft':
                        if (this.getCursorPosition() === 0) {
                            e.preventDefault();
                            if (focus.param !== undefined) {
                                // In nested grid
                                if (focus.paramCol > 0) {
                                    this.focusNestedCell(row, focus.param, 0);
                                } else {
                                    this.focusCell(row, 0);
                                }
                            } else if (col > 0) {
                                this.focusNestedCell(row, 0, 0);
                            }
                        }
                        break;
                    
                    case 'ArrowRight':
                        const cell = document.activeElement;
                        if (this.getCursorPosition() === cell.textContent.length) {
                            e.preventDefault();
                            if (focus.param !== undefined) {
                                // In nested grid
                                if (focus.paramCol < 1) {
                                    this.focusNestedCell(row, focus.param, 1);
                                } else {
                                    this.focusCell(row + 1, 0);
                                }
                            } else if (col === 0) {
                                this.focusNestedCell(row, 0, 0);
                            }
                        }
                        break;
                    
                    case 'Tab':
                        e.preventDefault();
                        if (e.shiftKey) {
                            // Shift+Tab: go to previous cell
                            this.navigatePrevious();
                        } else {
                            // Tab: go to next cell
                            this.navigateNext();
                        }
                        break;
                    
                    case 'Enter':
                        e.preventDefault();
                        if (focus.param !== undefined) {
                            // In nested grid, move to next row
                            if (focus.param < 1) {
                                this.focusNestedCell(row, focus.param + 1, focus.paramCol);
                            } else {
                                this.focusCell(row + 1, 0);
                            }
                        } else {
                            this.focusCell(row + 1, col);
                        }
                        break;
                }
            }

            focusCell(row, col) {
                // Ensure row exists
                while (row >= this.rows.length) {
                    this.addRow();
                    this.render();
                }

                const cell = this.container.querySelector(`[data-row="${row}"][data-col="${col}"]:not([data-param])`);
                if (cell) {
                    cell.focus();
                    this.currentFocus = { row, col };
                }
            }

            focusNestedCell(row, param, paramCol) {
                // Ensure row exists
                while (row >= this.rows.length) {
                    this.addRow();
                    this.render();
                }

                const cell = this.container.querySelector(`[data-row="${row}"][data-param="${param}"][data-param-col="${paramCol}"]`);
                if (cell) {
                    cell.focus();
                    this.currentFocus = { row, col: 1, param, paramCol };
                }
            }

            navigateNext() {
                const focus = this.currentFocus;
                const { row, col } = focus;

                if (col === 0) {
                    // From command to first nested cell
                    this.focusNestedCell(row, 0, 0);
                } else if (focus.param !== undefined) {
                    // In nested grid
                    if (focus.paramCol === 0) {
                        // From key to value
                        this.focusNestedCell(row, focus.param, 1);
                    } else if (focus.param === 0) {
                        // From first value to second key
                        this.focusNestedCell(row, 1, 0);
                    } else {
                        // From second value to next command
                        this.focusCell(row + 1, 0);
                    }
                }
            }

            navigatePrevious() {
                const focus = this.currentFocus;
                const { row, col } = focus;

                if (col === 0 && row > 0) {
                    // From command to previous nested cell (last one)
                    this.focusNestedCell(row - 1, 1, 1);
                } else if (focus.param !== undefined) {
                    // In nested grid
                    if (focus.paramCol === 1) {
                        // From value to key
                        this.focusNestedCell(row, focus.param, 0);
                    } else if (focus.param === 1) {
                        // From second key to first value
                        this.focusNestedCell(row, 0, 1);
                    } else {
                        // From first key to command
                        this.focusCell(row, 0);
                    }
                }
            }

            restoreFocus() {
                const focus = this.currentFocus;
                if (focus.param !== undefined) {
                    this.focusNestedCell(focus.row, focus.param, focus.paramCol);
                } else {
                    this.focusCell(focus.row, focus.col);
                }
            }

            getCursorPosition() {
                const selection = window.getSelection();
                return selection.anchorOffset;
            }
        }

        // Initialize the spreadsheet
        document.addEventListener('DOMContentLoaded', () => {
            const grid = document.getElementById('grid');
            new MinimalSpreadsheet(grid);
        });
    </script>
</body>
</html> 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clean Rowspan Grid</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1e1e1e;
            color: #ffffff;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 14px;
            overflow: hidden;
        }

        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: row;
        }

        .left-panel {
            width: 400px;
            height: 100vh;
            background: #1a1a1a;
            border-right: 1px solid #404040;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .right-panel {
            flex: 1;
            background: #2a2a2a;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666666;
            font-style: italic;
        }

        .grid-container {
            flex: 1;
            overflow: auto;
            padding: 8px;
        }

        .grid {
            width: 100%;
            border-collapse: collapse;
        }

        .cell {
            border: 1px solid #404040;
            padding: 8px 12px;
            vertical-align: top;
            outline: none;
            min-height: 40px;
            line-height: 24px;
        }

        .cell:focus {
            background: #2d2d2d;
            border: 2px solid #4fc3f7;
        }

        .cell.locked:focus {
            background: inherit;
        }

        .cell.locked:focus::selection {
            background: #006699;
            color: #ffffff;
        }

        .command-cell {
            width: 120px;
            font-weight: bold;
            color: #4fc3f7;
            background: #242424;
        }

        .param-key {
            width: 120px;
            color: #ffb74d;
            background: #282828;
        }

        .param-value {
            color: #81c784;
            background: #1e1e1e;
        }

        .cell[contenteditable="true"]:empty::before {
            content: attr(data-placeholder);
            color: #666666;
            font-style: italic;
        }

        .cell.blink {
            animation: blink-warning 0.5s ease-in-out;
        }

        @keyframes blink-warning {
            0% { background-color: inherit; }
            50% { background-color: #ff6b6b; }
            100% { background-color: inherit; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-panel">
            <div class="grid-container">
                <table class="grid" id="grid">
                    <!-- Rows will be generated dynamically -->
                </table>
            </div>
        </div>
        <div class="right-panel">
            Generated code will appear here...
        </div>
    </div>

    <script>
        // DSL definition with commands and their parameters  
        const STAMP_DSL = {
            commands: ['circle', 'rect', 'line', 'arc', 'text', 'group', 'repeat'],
            parameters: {
                'circle': ['radius', 'x', 'y', 'fill', 'stroke'],
                'rect': ['width', 'height', 'x', 'y', 'fill', 'stroke'],
                'line': ['x1', 'y1', 'x2', 'y2', 'stroke'],
                'arc': ['radius', 'startAngle', 'endAngle', 'x', 'y', 'fill', 'stroke'],
                'text': ['content', 'x', 'y', 'fontSize', 'fill'],
                'group': ['name'],
                'repeat': ['count', 'dx', 'dy', 'rotate']
            }
        };

        class StableRowspanGrid {
            constructor(container) {
                this.container = container;
                this.currentFocus = null;
                this.cursorPosition = 0;
                this.isExpanding = false;
                this.originalValues = new Map(); // Track original values for ESC restore
                this.commands = [
                    {
                        name: '',
                        nameIsLocked: false,
                        parameters: [
                            { key: '', value: '', keyIsLocked: false }
                        ]
                    }
                ];
                
                this.render();
                this.setupEventListeners();
                this.focusFirstCell();
            }

            render() {
                let html = '';
                this.commands.forEach((command, commandIndex) => {
                    const paramCount = command.parameters.length;
                    
                    // First parameter row with command cell 
                    html += `
                        <tr>
                            <td class="cell command-cell ${command.nameIsLocked ? 'locked' : ''}" 
                                rowspan="${paramCount}"
                                contenteditable="true" 
                                data-command-index="${commandIndex}"
                                data-placeholder="${command.name ? command.name : 'command...'}">${command.name}</td>
                            <td class="cell param-key ${command.parameters[0].keyIsLocked ? 'locked' : ''}" 
                                contenteditable="true" 
                                data-command-index="${commandIndex}"
                                data-param-index="0"
                                data-placeholder="${command.parameters[0].key ? command.parameters[0].key : 'param...'}">${command.parameters[0].key}</td>
                            <td class="cell param-value" 
                                contenteditable="true" 
                                data-command-index="${commandIndex}"
                                data-param-index="0"
                                data-placeholder="${command.parameters[0].value ? command.parameters[0].value : 'value...'}">${command.parameters[0].value}</td>
                        </tr>
                    `;

                    // Additional parameter rows
                    for (let paramIndex = 1; paramIndex < paramCount; paramIndex++) {
                        const param = command.parameters[paramIndex];
                        html += `
                            <tr>
                                <td class="cell param-key ${param.keyIsLocked ? 'locked' : ''}" 
                                    contenteditable="true" 
                                    data-command-index="${commandIndex}"
                                    data-param-index="${paramIndex}"
                                    data-placeholder="${param.key ? param.key : 'param...'}">${param.key}</td>
                                <td class="cell param-value" 
                                    contenteditable="true" 
                                    data-command-index="${commandIndex}"
                                    data-param-index="${paramIndex}"
                                    data-placeholder="${param.value ? param.value : 'value...'}">${param.value}</td>
                            </tr>
                        `;
                    }
                });
                
                this.container.innerHTML = html;
            }

            isValidCommand(command) {
                return STAMP_DSL.commands.includes(command);
            }

            isValidParameter(command, param) {
                return STAMP_DSL.parameters[command]?.includes(param) || false;
            }

            getCommandSuggestion(partial) {
                return STAMP_DSL.commands.find(cmd => 
                    cmd.startsWith(partial) && cmd !== partial
                );
            }

            getParameterSuggestion(command, partial) {
                const params = STAMP_DSL.parameters[command];
                if (!params) return null;
                return params.find(param => 
                    param.startsWith(partial) && param !== partial
                );
            }

            isValidContentForCell(element) {
                const content = element.textContent.trim();
                if (!content) return true; // Empty is always valid

                if (element.classList.contains('command-cell')) {
                    return this.isValidCommand(content);
                } else if (element.classList.contains('param-key')) {
                    const commandIndex = parseInt(element.dataset.commandIndex);
                    const commandName = this.commands[commandIndex].name;
                    return !commandName || this.isValidParameter(commandName, content);
                }
                return true; // param-value cells are always valid
            }

            setupEventListeners() {
                // Input handling
                this.container.addEventListener('input', (e) => {
                    if (e.target.classList.contains('cell')) {
                        if (this.isLockedCell(e.target)) {
                            e.preventDefault();
                            this.preventEditAndBlink(e.target);
                            return;
                        }
                        this.saveCursorPosition();
                        this.handleCellInput(e.target);
                    }
                });

                // Keypress prevention for locked cells
                this.container.addEventListener('keypress', (e) => {
                    if (e.target.classList.contains('cell') && this.isLockedCell(e.target)) {
                        if (e.key.length === 1) {
                            e.preventDefault();
                            this.preventEditAndBlink(e.target);
                        }
                    }
                });

                // Keyboard navigation
                this.container.addEventListener('keydown', (e) => {
                    this.handleKeydown(e);
                });

                // Focus handling
                this.container.addEventListener('focus', (e) => {
                    if (e.target.classList.contains('cell')) {
                        this.currentFocus = e.target;
                        this.handleCellFocus(e.target);
                    }
                }, true);

                // Blur handling with validation
                this.container.addEventListener('blur', (e) => {
                    if (!e.target.classList.contains('cell')) return;
                    if (this.isExpanding) return;
                    
                    const content = e.target.textContent.trim();
                    
                    // Clear invalid content
                    if (e.target.classList.contains('command-cell') && content && !this.isValidCommand(content)) {
                        e.target.innerHTML = '';
                        e.target.setAttribute('data-placeholder', 'command...');
                        this.updateCommandName(e.target, '');
                        return;
                    }
                    
                    if (e.target.classList.contains('param-key') && content) {
                        const commandIndex = parseInt(e.target.dataset.commandIndex);
                        const commandName = this.commands[commandIndex].name;
                        if (commandName && !this.isValidParameter(commandName, content)) {
                            e.target.innerHTML = '';
                            e.target.setAttribute('data-placeholder', 'param...');
                            this.updateParameterKey(e.target, '');
                            return;
                        }
                    }
                    
                    // Auto-lock valid content
                    if ((e.target.classList.contains('command-cell') || e.target.classList.contains('param-key')) 
                        && content && !this.isLockedCell(e.target)) {
                        this.lockCell(e.target);
                    }
                }, true);
            }

            handleCellInput(element) {
                if (element.classList.contains('command-cell')) {
                    this.updateCommandName(element, element.textContent);
                } else if (element.classList.contains('param-key')) {
                    this.updateParameterKey(element, element.textContent);
                } else if (element.classList.contains('param-value')) {
                    this.updateParameterValue(element, element.textContent);
                }
                
                // Check if we need to expand
                if (this.shouldExpandGrid(element)) {
                    this.expandGrid(element);
                }
            }

            updateCommandName(element, content) {
                const commandIndex = parseInt(element.dataset.commandIndex);
                this.commands[commandIndex].name = content;
            }

            updateParameterKey(element, content) {
                const commandIndex = parseInt(element.dataset.commandIndex);
                const paramIndex = parseInt(element.dataset.paramIndex);
                this.commands[commandIndex].parameters[paramIndex].key = content;
            }

            updateParameterValue(element, content) {
                const commandIndex = parseInt(element.dataset.commandIndex);
                const paramIndex = parseInt(element.dataset.paramIndex);
                this.commands[commandIndex].parameters[paramIndex].value = content;
            }

            shouldExpandGrid(element) {
                const content = element.textContent.trim();
                if (!content) return false;
                
                if (element.classList.contains('command-cell')) {
                    const commandIndex = parseInt(element.dataset.commandIndex);
                    return commandIndex === this.commands.length - 1;
                } else if (element.classList.contains('param-key')) {
                    const commandIndex = parseInt(element.dataset.commandIndex);
                    const paramIndex = parseInt(element.dataset.paramIndex);
                    const command = this.commands[commandIndex];
                    return paramIndex === command.parameters.length - 1;
                }
                return false;
            }

            expandGrid(element) {
                this.isExpanding = true;
                
                if (element.classList.contains('command-cell')) {
                    this.commands.push({
                        name: '',
                        nameIsLocked: false,
                        parameters: [{ key: '', value: '', keyIsLocked: false }]
                    });
                } else if (element.classList.contains('param-key')) {
                    const commandIndex = parseInt(element.dataset.commandIndex);
                    this.commands[commandIndex].parameters.push({ key: '', value: '', keyIsLocked: false });
                }
                
                this.render();
                this.restoreFocus();
                this.isExpanding = false;
            }

            handleKeydown(e) {
                if (!this.currentFocus) return;

                const cells = Array.from(this.container.querySelectorAll('.cell'));
                const currentIndex = cells.indexOf(this.currentFocus);
                const isLocked = this.isLockedCell(this.currentFocus);

                switch (e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        if (!isLocked && (this.currentFocus.classList.contains('command-cell') || this.currentFocus.classList.contains('param-key'))) {
                            this.handleArrowNavigation(this.currentFocus, () => this.navigateUp(cells, currentIndex));
                        } else {
                            this.navigateUp(cells, currentIndex);
                        }
                        break;
                    
                    case 'ArrowDown':
                        e.preventDefault();
                        if (!isLocked && (this.currentFocus.classList.contains('command-cell') || this.currentFocus.classList.contains('param-key'))) {
                            this.handleArrowNavigation(this.currentFocus, () => this.navigateDown(cells, currentIndex));
                        } else {
                            this.navigateDown(cells, currentIndex);
                        }
                        break;
                    
                    case 'ArrowLeft':
                        if (isLocked || this.getCursorPosition() === 0) {
                            e.preventDefault();
                            if (!isLocked && (this.currentFocus.classList.contains('command-cell') || this.currentFocus.classList.contains('param-key'))) {
                                this.handleArrowNavigation(this.currentFocus, () => this.navigateLeft(cells, currentIndex));
                            } else {
                                this.navigateLeft(cells, currentIndex);
                            }
                        }
                        break;
                    
                    case 'ArrowRight':
                        if (isLocked || this.getCursorPosition() === this.currentFocus.textContent.length) {
                            e.preventDefault();
                            if (!isLocked && (this.currentFocus.classList.contains('command-cell') || this.currentFocus.classList.contains('param-key'))) {
                                this.handleArrowNavigation(this.currentFocus, () => this.navigateRight(cells, currentIndex));
                            } else {
                                this.navigateRight(cells, currentIndex);
                            }
                        }
                        break;
                    
                    case 'Tab':
                        e.preventDefault();
                        if (!isLocked && (this.currentFocus.classList.contains('command-cell') || this.currentFocus.classList.contains('param-key'))) {
                            // Try tab completion first
                            if (this.handleTabCompletion(this.currentFocus)) {
                                return;
                            }
                            // If no completion and content is invalid, blink
                            if (!this.isValidContentForCell(this.currentFocus)) {
                                this.preventEditAndBlink(this.currentFocus);
                                return;
                            }
                        }
                        
                        // Normal tab navigation
                        if (e.shiftKey) {
                            this.focusCell(cells, Math.max(0, currentIndex - 1));
                        } else {
                            this.focusCell(cells, Math.min(cells.length - 1, currentIndex + 1));
                        }
                        break;
                    
                    case 'Enter':
                        e.preventDefault();
                        if (isLocked) {
                            this.unlockCell(this.currentFocus);
                            this.enterEditMode(this.currentFocus);
                        } else if (this.currentFocus.classList.contains('command-cell') || this.currentFocus.classList.contains('param-key')) {
                            const content = this.currentFocus.textContent.trim();
                            if (content) {
                                if (this.isValidContentForCell(this.currentFocus)) {
                                    this.lockCell(this.currentFocus);
                                    setTimeout(() => {
                                        this.selectAllText(this.currentFocus);
                                    }, 0);
                                } else {
                                    // Invalid content, blink instead of navigating
                                    this.preventEditAndBlink(this.currentFocus);
                                }
                            } else {
                                // Empty content, just navigate
                                this.navigateDown(cells, currentIndex);
                            }
                        } else {
                            this.navigateDown(cells, currentIndex);
                        }
                        break;

                    case 'Escape':
                        e.preventDefault();
                        if (!isLocked && this.originalValues.has(this.currentFocus)) {
                            // Restore original value
                            const originalValue = this.originalValues.get(this.currentFocus);
                            this.currentFocus.textContent = originalValue;
                            
                            // Update model
                            if (this.currentFocus.classList.contains('command-cell')) {
                                this.updateCommandName(this.currentFocus, originalValue);
                            } else if (this.currentFocus.classList.contains('param-key')) {
                                this.updateParameterKey(this.currentFocus, originalValue);
                            } else if (this.currentFocus.classList.contains('param-value')) {
                                this.updateParameterValue(this.currentFocus, originalValue);
                            }
                            
                            // If it was locked before, lock it again
                            if (originalValue && (this.currentFocus.classList.contains('command-cell') || this.currentFocus.classList.contains('param-key'))) {
                                this.lockCell(this.currentFocus);
                                setTimeout(() => {
                                    this.selectAllText(this.currentFocus);
                                }, 0);
                            }
                            
                            // Clean up
                            this.originalValues.delete(this.currentFocus);
                        }
                        break;
                        
                    case 'Backspace':
                    case 'Delete':
                        if (isLocked) {
                            e.preventDefault();
                            this.unlockAndClearCell(this.currentFocus);
                        }
                        break;
                }
            }

            handleTabCompletion(element) {
                if (!element || this.isLockedCell(element)) return false;

                const content = element.textContent.trim();
                if (!content) return false;

                let suggestion = null;
                
                if (element.classList.contains('command-cell')) {
                    suggestion = this.getCommandSuggestion(content);
                } else if (element.classList.contains('param-key')) {
                    const commandIndex = parseInt(element.dataset.commandIndex);
                    const commandName = this.commands[commandIndex].name;
                    if (commandName) {
                        suggestion = this.getParameterSuggestion(commandName, content);
                    }
                }

                if (suggestion) {
                    // Clean replacement to fix text corruption
                    element.textContent = suggestion;
                    
                    // Update model
                    if (element.classList.contains('command-cell')) {
                        this.updateCommandName(element, suggestion);
                    } else if (element.classList.contains('param-key')) {
                        this.updateParameterKey(element, suggestion);
                    }
                    
                    // Place cursor at end
                    const range = document.createRange();
                    const textNode = element.firstChild;
                    if (textNode && textNode.nodeType === Node.TEXT_NODE) {
                        range.setStart(textNode, textNode.textContent.length);
                        range.setEnd(textNode, textNode.textContent.length);
                    } else {
                        range.selectNodeContents(element);
                        range.collapse(false);
                    }
                    
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    return true;
                }

                return false;
            }

            // Navigation methods 
            navigateUp(cells, currentIndex) {
                const currentCell = cells[currentIndex];
                for (let i = currentIndex - 1; i >= 0; i--) {
                    if (this.isInSameColumn(currentCell, cells[i])) {
                        this.focusCell(cells, i);
                        return;
                    }
                }
            }

            navigateDown(cells, currentIndex) {
                const currentCell = cells[currentIndex];
                for (let i = currentIndex + 1; i < cells.length; i++) {
                    if (this.isInSameColumn(currentCell, cells[i])) {
                        this.focusCell(cells, i);
                        return;
                    }
                }
            }

            navigateLeft(cells, currentIndex) {
                const currentCell = cells[currentIndex];
                
                if (currentCell.classList.contains('param-key')) {
                    const commandIndex = parseInt(currentCell.dataset.commandIndex);
                    const commandCell = cells.find(cell => 
                        cell.classList.contains('command-cell') && 
                        parseInt(cell.dataset.commandIndex) === commandIndex
                    );
                    if (commandCell) {
                        const commandCellIndex = cells.indexOf(commandCell);
                        this.focusCell(cells, commandCellIndex);
                        return;
                    }
                }
                
                for (let i = currentIndex - 1; i >= 0; i--) {
                    if (this.isInSameRow(currentCell, cells[i])) {
                        this.focusCell(cells, i);
                        return;
                    }
                }
            }

            navigateRight(cells, currentIndex) {
                const currentCell = cells[currentIndex];
                for (let i = currentIndex + 1; i < cells.length; i++) {
                    if (this.isInSameRow(currentCell, cells[i])) {
                        this.focusCell(cells, i);
                        return;
                    }
                }
            }

            isInSameColumn(cell1, cell2) {
                return (cell1.classList.contains('command-cell') && cell2.classList.contains('command-cell')) ||
                       (cell1.classList.contains('param-key') && cell2.classList.contains('param-key')) ||
                       (cell1.classList.contains('param-value') && cell2.classList.contains('param-value'));
            }

            isInSameRow(cell1, cell2) {
                return cell1.closest('tr') === cell2.closest('tr');
            }

            focusCell(cells, index) {
                if (index >= 0 && index < cells.length) {
                    const cell = cells[index];
                    cell.focus();
                    this.currentFocus = cell;
                    
                    if (this.isLockedCell(cell)) {
                        setTimeout(() => this.selectAllText(cell), 0);
                    }
                }
            }

            focusFirstCell() {
                setTimeout(() => {
                    const firstCell = this.container.querySelector('.cell');
                    if (firstCell) {
                        firstCell.focus();
                        this.currentFocus = firstCell;
                    }
                }, 100);
            }

            restoreFocus() {
                if (this.currentFocus) {
                    const commandIndex = this.currentFocus.dataset.commandIndex;
                    const paramIndex = this.currentFocus.dataset.paramIndex;
                    
                    let selector;
                    if (this.currentFocus.classList.contains('command-cell')) {
                        selector = `[data-command-index="${commandIndex}"].command-cell`;
                    } else if (this.currentFocus.classList.contains('param-key')) {
                        selector = `[data-command-index="${commandIndex}"][data-param-index="${paramIndex}"].param-key`;
                    } else {
                        selector = `[data-command-index="${commandIndex}"][data-param-index="${paramIndex}"].param-value`;
                    }
                    
                    const newCell = this.container.querySelector(selector);
                    if (newCell) {
                        newCell.focus();
                        this.currentFocus = newCell;
                        this.restoreCursorPosition(newCell);
                    }
                }
            }

            handleCellFocus(element) {
                if (this.isLockedCell(element)) {
                    setTimeout(() => this.selectAllText(element), 0);
                }
            }

            lockCell(element) {
                const commandIndex = parseInt(element.dataset.commandIndex);
                
                if (element.classList.contains('command-cell')) {
                    this.commands[commandIndex].nameIsLocked = true;
                } else if (element.classList.contains('param-key')) {
                    const paramIndex = parseInt(element.dataset.paramIndex);
                    this.commands[commandIndex].parameters[paramIndex].keyIsLocked = true;
                }
                
                element.classList.add('locked');
                element.style.userSelect = 'all';
            }

            unlockCell(element) {
                const commandIndex = parseInt(element.dataset.commandIndex);
                
                // Store original value for ESC restore
                this.originalValues.set(element, element.textContent.trim());
                
                if (element.classList.contains('command-cell')) {
                    this.commands[commandIndex].nameIsLocked = false;
                } else if (element.classList.contains('param-key')) {
                    const paramIndex = parseInt(element.dataset.paramIndex);
                    this.commands[commandIndex].parameters[paramIndex].keyIsLocked = false;
                }
                
                element.classList.remove('locked');
                element.style.userSelect = '';
            }

            unlockAndClearCell(element) {
                const commandIndex = parseInt(element.dataset.commandIndex);
                
                if (element.classList.contains('command-cell')) {
                    this.commands[commandIndex].name = '';
                    this.commands[commandIndex].nameIsLocked = false;
                } else if (element.classList.contains('param-key')) {
                    const paramIndex = parseInt(element.dataset.paramIndex);
                    this.commands[commandIndex].parameters[paramIndex].key = '';
                    this.commands[commandIndex].parameters[paramIndex].keyIsLocked = false;
                }
                
                element.textContent = '';
                element.classList.remove('locked');
                element.style.userSelect = '';
            }

            isLockedCell(element) {
                if (!element.classList.contains('command-cell') && !element.classList.contains('param-key')) {
                    return false;
                }
                
                const commandIndex = parseInt(element.dataset.commandIndex);
                
                if (element.classList.contains('command-cell')) {
                    return this.commands[commandIndex].nameIsLocked;
                } else if (element.classList.contains('param-key')) {
                    const paramIndex = parseInt(element.dataset.paramIndex);
                    return this.commands[commandIndex].parameters[paramIndex].keyIsLocked;
                }
                
                return false;
            }

            // Utility methods
            getCursorPosition() {
                const selection = window.getSelection();
                return selection.anchorOffset;
            }

            saveCursorPosition() {
                if (this.currentFocus) {
                    this.cursorPosition = this.getCursorPosition();
                }
            }

            restoreCursorPosition(cell) {
                if (!cell) return;
                
                const range = document.createRange();
                const textNode = cell.firstChild;
                if (textNode && textNode.nodeType === Node.TEXT_NODE) {
                    const position = Math.min(this.cursorPosition, textNode.textContent.length);
                    range.setStart(textNode, position);
                    range.setEnd(textNode, position);
                    
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }

            enterEditMode(element) {
                setTimeout(() => {
                    const range = document.createRange();
                    const textNode = element.firstChild;
                    if (textNode && textNode.nodeType === Node.TEXT_NODE) {
                        range.setStart(textNode, textNode.textContent.length);
                        range.setEnd(textNode, textNode.textContent.length);
                    } else {
                        range.selectNodeContents(element);
                        range.collapse(false);
                    }
                    
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }, 0);
            }

            selectAllText(element) {
                const range = document.createRange();
                range.selectNodeContents(element);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
            }

            preventEditAndBlink(element) {
                element.classList.add('blink');
                setTimeout(() => {
                    element.classList.remove('blink');
                }, 500);
            }

            clearCellContent(element) {
                element.textContent = '';
                
                // Reset placeholder
                if (element.classList.contains('command-cell')) {
                    element.setAttribute('data-placeholder', 'command...');
                    this.updateCommandName(element, '');
                } else if (element.classList.contains('param-key')) {
                    element.setAttribute('data-placeholder', 'param...');
                    this.updateParameterKey(element, '');
                } else if (element.classList.contains('param-value')) {
                    element.setAttribute('data-placeholder', 'value...');
                    this.updateParameterValue(element, '');
                }
            }

            handleArrowNavigation(element, navigationCallback) {
                const content = element.textContent.trim();
                
                if (!content) {
                    // Empty content, just navigate
                    navigationCallback();
                    return;
                }

                // Check for suggestions (autocomplete)
                let suggestion = null;
                if (element.classList.contains('command-cell')) {
                    suggestion = this.getCommandSuggestion(content);
                } else if (element.classList.contains('param-key')) {
                    const commandIndex = parseInt(element.dataset.commandIndex);
                    const commandName = this.commands[commandIndex].name;
                    if (commandName) {
                        suggestion = this.getParameterSuggestion(commandName, content);
                    }
                }

                if (suggestion) {
                    // Autocomplete and then navigate
                    element.textContent = suggestion;
                    
                    // Update model
                    if (element.classList.contains('command-cell')) {
                        this.updateCommandName(element, suggestion);
                    } else if (element.classList.contains('param-key')) {
                        this.updateParameterKey(element, suggestion);
                    }
                } else {
                    // No match, clear content and reset placeholder
                    this.clearCellContent(element);
                }
                
                // Always navigate after handling content
                navigationCallback();
            }
        }

        // Initialize the grid
        document.addEventListener('DOMContentLoaded', () => {
            const grid = document.getElementById('grid');
            new StableRowspanGrid(grid);
        });
    </script>
</body>
</html>
